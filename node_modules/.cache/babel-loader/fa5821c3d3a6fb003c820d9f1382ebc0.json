{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _advanceWidth = _interopRequireDefault(require(\"../attributedString/advanceWidth\"));\n\nvar _leadingOffset = _interopRequireDefault(require(\"../attributedString/leadingOffset\"));\n\nvar _trailingOffset = _interopRequireDefault(require(\"../attributedString/trailingOffset\"));\n\nvar _dropLast = _interopRequireDefault(require(\"../attributedString/dropLast\"));\n\nvar ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n/**\r\n * Remove new line char at the end of line if present\r\n *\r\n * @param  {Object}  line\r\n * @return {Object} line\r\n */\n\nvar removeNewLine = R.when(R.compose(R.equals('\\n'), R.last, R.prop('string')), _dropLast.default);\nvar getOverflowLeft = R.converge(R.add, [R.propOr(0, 'overflowLeft'), _leadingOffset.default]);\nvar getOverflowRight = R.converge(R.add, [R.propOr(0, 'overflowRight'), _trailingOffset.default]);\n/**\r\n * Ignore whitespace at the start and end of a line for alignment\r\n *\r\n * @param  {Object}  line\r\n * @return {Object} line\r\n */\n\nvar adjustOverflow = function adjustOverflow(line) {\n  var overflowLeft = getOverflowLeft(line);\n  var overflowRight = getOverflowRight(line);\n  return R.compose(R.assoc('overflowLeft', overflowLeft), R.assoc('overflowRight', overflowRight), R.evolve({\n    box: R.evolve({\n      x: R.subtract(R.__, overflowLeft),\n      width: R.add(overflowLeft + overflowRight)\n    })\n  }))(line);\n};\n/**\r\n * Performs line justification by calling appropiate engine\r\n *\r\n * @param  {Object}  engines\r\n * @param  {Object}  layout options\r\n * @param  {string}  text align\r\n * @param  {Object}  line\r\n * @return {Object} line\r\n */\n\n\nvar justifyLine = function justifyLine(engines, options, align) {\n  return function (line) {\n    var lineWidth = (0, _advanceWidth.default)(line);\n    var alignFactor = ALIGNMENT_FACTORS[align] || 0;\n    var remainingWidth = Math.max(0, line.box.width - lineWidth);\n    var shouldJustify = align === 'justify' || lineWidth > line.box.width;\n    return R.compose(R.when(R.always(shouldJustify), engines.justification(options)), R.evolve({\n      box: R.evolve({\n        x: R.add(remainingWidth * alignFactor)\n      })\n    }))(line);\n  };\n};\n/**\r\n * Finalize line by performing line justification\r\n * and text decoration (using appropiate engines)\r\n *\r\n * @param  {Object}  engines\r\n * @param  {Object}  layout options\r\n * @param  {Object}  line\r\n * @param  {number}  line index\r\n * @param  {Array}  total lines\r\n * @return {Object} line\r\n */\n\n\nvar finalizeBlock = function finalizeBlock(engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n\n  return function (line, i, lines) {\n    var isLastFragment = i === lines.length - 1;\n    var style = R.pathOr({}, ['runs', 0, 'attributes'], line);\n    var align = isLastFragment ? style.alignLastLine : style.align;\n    return R.compose(engines.textDecoration(options), justifyLine(engines, options, align), adjustOverflow, removeNewLine)(line);\n  };\n};\n/**\r\n * Finalize line block by performing line justification\r\n * and text decoration (using appropiate engines)\r\n *\r\n * @param  {Object}  engines\r\n * @param  {Object}  layout options\r\n * @param  {Array}  line blocks\r\n * @return {Array} line blocks\r\n */\n\n\nvar finalizeFragments = function finalizeFragments(engines, options, blocks) {\n  var blockFinalizer = finalizeBlock(engines, options);\n  return blocks.map(function (block) {\n    return block.map(blockFinalizer);\n  });\n};\n\nvar _default = R.curryN(3, finalizeFragments);\n\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}