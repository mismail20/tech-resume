{"ast":null,"code":"import _arity from './internal/_arity.js';\nimport _concat from './internal/_concat.js';\nimport _curry2 from './internal/_curry2.js';\n/**\r\n * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned\r\n * function evaluates the `tryer`; if it does not throw, it simply returns the\r\n * result. If the `tryer` *does* throw, the returned function evaluates the\r\n * `catcher` function and returns its result. Note that for effective\r\n * composition with this function, both the `tryer` and `catcher` functions\r\n * must return the same type of results.\r\n *\r\n * @func\r\n * @memberOf R\r\n * @since v0.20.0\r\n * @category Function\r\n * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)\r\n * @param {Function} tryer The function that may throw.\r\n * @param {Function} catcher The function that will be evaluated if `tryer` throws.\r\n * @return {Function} A new function that will catch exceptions and send then to the catcher.\r\n * @example\r\n *\r\n *      R.tryCatch(R.prop('x'), R.F)({x: true}); //=> true\r\n *      R.tryCatch(() => { throw 'foo'}, R.always('catched'))('bar') // => 'catched'\r\n *      R.tryCatch(R.times(R.identity), R.always([]))('s') // => []\r\n `` */\n\nvar tryCatch = /*#__PURE__*/_curry2(function _tryCatch(tryer, catcher) {\n  return _arity(tryer.length, function () {\n    try {\n      return tryer.apply(this, arguments);\n    } catch (e) {\n      return catcher.apply(this, _concat([e], arguments));\n    }\n  });\n});\n\nexport default tryCatch;","map":null,"metadata":{},"sourceType":"module"}